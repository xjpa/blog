---
layout: post
title: 'Study the Classics'
description: An advice for college students
category: articles
tags: [advice]
comments: true
---

You want to really get ahead in life while youre in university?

Take an elective class on the classics. I'm talking Philosophy, Foreign Languages, Latin.

Software engineers, might think that focusing solely on technical skills is the key to success. But here's a counterintuitive piece of advice: take a class on the classics. Why? Because at its core, software engineering, like all human endeavors, is fundamentally about interacting with people.

<!-- more -->

That's what studying the classics will get you: talking to groups of people, learning how to craft Roman Emperor-tier speeches, arguing, socratic/constructivist learning, and much much more.

While you're busy optimizing your for-loops, the guys who are really climbing the corporate ladder are the ones who can string together a coherent sentence without sweating through their shitty t-shirts. And they learn that black magic from having a good foundation of the classics. Classical education has historically been the core education of great business and historical leaders in the past, and many elite universities still mix it in their curriculum.

<center>
  <figure>
    <img src="/photos/2024/aristotle_alexander.jpg" alt="Aristotle teaches Alexander the Great">
    <figcaption style="margin-top: 10px; font-size: 18px;">Aristotle & Alexander the Great by Laplante (1866)</figcaption>
  </figure>
</center>

Philosophy, foreign languages, and even Latin. Yeah, Latin. The language so old it makes COBOL look cutting-edge. But trust me, this stuff is legit.

At the end of the day, all of life - including your precious coding career - is about navigating around these weird, unpredictable entities we call humans. And let me tell you, understanding humans is a hell of a lot harder than understanding computers.

## Constructivism dominates

Even math - yes, that pure, logical objective landscape - is a human construct

I've been reading recently about the Philosophy of Mathematics and the main thing you'll realize is that mathematics is a human activity. It is a human construct.

Although of course there is an idea in [Platonism](https://en.wikipedia.org/wiki/Philosophy_of_mathematics#Platonism), where it views that math is timeless and has always existed, and that us humans are just discovering these entities rather than proving them.

Even still, majority of the philosophies surrounding math, points to it being a human activity.

So there's this Dutch dude named [L. E. J. Brouwer](https://en.wikipedia.org/wiki/L._E._J._Brouwer) and no, it's not the guy who invented the [fixed-point theorem](https://en.wikipedia.org/wiki/Brouwer_fixed-point_theorem), although... wait, yeah, actually it is that guy. Anyway, Brouwer starts this thing called [intuitionism](https://en.wikipedia.org/wiki/Intuitionism), which says (copy pasting from wikipedia): "the truth of a mathematical statement is a subjective claim"

Now, before you start screaming "BS!" and close this page, hear me out. This isn't just some reddit neckbeard circle-jerk. This stuff has real implications for us programmers

Take infinity, for example. Classical math is all about that "actual infinity" - infinite sets, infinitely long decimals, you know the drill. But Brouwer and his intuitionionist bros are like, "Nah, bruh. We're more into that potential infinity." It's like the difference between having infinite pizzas ([actual infinity](https://en.wikipedia.org/wiki/Actual_infinity), e.g. infinite sets) and being able to always order one more pizza or "potential infinity", the idea that we can always construct a larger number.

## Philosophy meets Computer Science

And guess what? When it comes to computers, Brouwer's boys are onto something. Your machine doesn't deal with actual infinity any more than it deals with having actual girlfriends (waifu pillows don't count). Nah, in the world of silicon and electrons, we're all about that potential infinity life.

This potential infinity is what we're talking about when we say that math is a human activity, and is often something that is much more clear when we go to the realm of computer science.

Computers like humans, work with finite resources and cant really process "actual infinity" and instead work with potential infinity through iterative processes. Like for example [infinite loops](https://en.wikipedia.org/wiki/Infinite_loop), while we conceptualize these as "infinite," in practice they're potential infinities limited by hardware constraints. You can look at more examples in computer science about how these underlying constructivist view perpetuate, for example in category theory and type theory:

> Intuitionistic type theory, as developed principally by Per Martin-LÃ¶f, is a codification of Brouwer's constructivism. Computable constructions are classified by types, which specify their abstract properties, rather than their concrete realizations as sets or other mathematical objects. Thus type theory is simultaneously a formulation of constructive mathematics and a comprehensive theory of computation.
>
> Type theory may be presented semantically, with types specifying the behavior of programs, or axiomatically, as a formal system admitting many interpretations. From a computer science perspective, the computational semantics is of the essence, and the role of formalisms is pragmatic, the means for writing programs and building proof checkers. A central tool in either case is the method of logical relations, or Tait's method. Semantically, a wide range of typing constructs can be expressed using logical relations. Formally, logical relations are fundamental to the study of properties of languages, such as decidability of typing or termination properties.
>
> from [Robert Harper](<https://en.wikipedia.org/wiki/Robert_Harper_(computer_scientist)>)'s Computational Type Theory [course at CMU](https://www.cs.cmu.edu/~rwh/courses/chtt/)

The course description, brings up intuitionistic type theory, constructivism. Then continues with "Computable constructions are classified by types, which specify their abstract properties, rather than their concrete realizations as sets or other mathematical objects." This focus on computable constructions aligns with the constructivist view and the idea of potential infinity, where objects are built up rather than assumed to exist as completed totalities.

Did you get all that? No? Then congrats, you're normal. But here's the thing: this whole word salad is talking about stuff that directly impacts how we write and think about code. It's all about building things up (constructivism) rather than assuming they exist (like "on-time projects" and "bug-free code").

## The point

So what's the point of all this philosophy talk? Simple: it's to show you that even the most technical, supposedly objective fields are shot through with human ideas, human limitations, and human BS.

And you know what that means? It means that to really excel in this field, you need more than just sick coding skills. You need to understand how humans think, how they communicate, and how they build complex systems of ideas.

In other words, you need to study the classics.

Look, I get it. You're busy. You've got code to write, Stack Overflow/GPT questions to copy-paste, and overpriced starbucks latte to chug. But if you want to be more than just another code monkey - if you want to be the person who leads the projects, who shapes the vision, who actually understands why we're building what we're building - then you need to broaden your horizons.

Take that philosophy class. Learn that dead language. Read those dusty old books. Because at the end of the day, software engineering isn't just about writing code. It's about solving human problems with human-created tools in human-centered systems.

And man, who knows? Maybe one day when you're giving a presentation to the board about why your project is 6 months behind schedule and 3x over budget, you'll be able to bust out a little Latin to smooth things over:

"Ceterum censeo JavaScript esse delendam."

("And furthermore, I believe JavaScript must be destroyed.")
